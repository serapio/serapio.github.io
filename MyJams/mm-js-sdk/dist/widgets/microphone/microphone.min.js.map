{"version":3,"sources":["microphone.js"],"names":["MM","initMMListener","listener","Listener","interimResults","on","result","resultIndex","results","event","hasVoiceResult","MindMeldMicrophone","emit","notAllowed","error","holdMessage","microphoneElement","querySelector","style","display","initClickHandlers","onMouseDown","listening","stop","holdTimeout","setTimeout","start","holdDuration","onMouseUp","clearTimeout","onMouseOut","micButton","addEventListener","e","stopPropagation","preventDefault","initUIHandlers","classList","add","continuous","remove","window","initialize","element","support","speechRecognition","cancel","subscriptions","eventName","callback","context","subscription","push","subscribers","undefined","args","Array","prototype","slice","call","arguments","forEach","this","apply","isContinuous"],"mappings":"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","file":"microphone.min.js","sourcesContent":["/* global MM */\n/* exported MindMeldMicrophone */\n\n/**\n * Adds the MindMeldMicrophone singleton object to the global namespace. The MindMeldMicrophone\n * exposes the following methods:\n * - initialize(): sets the listener config for MM.Listener, registers click handlers, and sets up volume monitor\n * - start(): starts recording\n * - stop(): stops recording\n * - listening(): returns a boolean indicating whether the mic is listening\n * - isContinuous(): returns a boolean indicating whether the mic is in continuous mode\n * - on(event, callback, context): register for a MindMeldMicrophone event. Events exposed:\n *  - 'init': fired after initialize() finishes\n *  - 'result': there is a speech-to-text result.  Passes a result object:\n *      `result = { transcript: (String), final: (Boolean) }`\n *  - 'start': the microphone starts recording\n *  - 'stop': the microphone stops recording\n *  - 'error': there was an error with the microphone.  Passes an event object:\n *      `event = { error: (String) }`\n */\n\n(function microphone (MM) {\n  'use strict';\n\n  var MindMeldMicrophone = window.MindMeldMicrophone = window.MindMeldMicrophone || {};\n  var listener;\n  var volumeMonitor;\n  var microphoneElement;\n  var hasVoiceResult;\n  // notAllowed == true if the browser doesn't support microphones.\n  var notAllowed;\n\n  /**\n   * `initialize()` checks for speech recognition support, initializes\n   * the volume monitor, and initializes mindmeld-microphone's\n   * click handlers.  It will emit an `'init'` event when successfully\n   * completed, or an `'error'` event in the case of an error.\n   *\n   * @param element a vanilla DOM element that contains the microphone.\n   * Generally `document.getElementById('mindmeld-microphone')`\n   */\n  MindMeldMicrophone.initialize = function initialize (element) {\n    microphoneElement = element;\n    hasVoiceResult = false;\n    notAllowed = false;\n\n    if (! MM.support.speechRecognition) {\n      microphoneElement.classList.add('disabled');\n      MindMeldMicrophone.emit('error', {error: 'speech-not-supported'});\n      notAllowed = true;\n      return;\n    }\n\n    initMMListener();\n\n    /* The volume monitor started causing \"audio-capture\" errors from webkitSpeechRecognition between\n     * Chrome 40.0.2214.38 beta (64-bit) and 40.0.2214.45 beta (64-bit). We are disabling it for now.\n     */\n    //initVolumeMonitor();\n    initClickHandlers();\n    initUIHandlers();\n    MindMeldMicrophone.emit('init');\n  };\n\n  // Sets the listener config for a new MM.Listener The mindmeld-microphone's\n  // event handlers publish the Listener events like onResult and onEnd\n  function initMMListener () {\n    listener = MM.listener = new MM.Listener({\n      interimResults: true\n    });\n\n    listener.on('result', function (result, resultIndex, results, event) {\n      hasVoiceResult = true;\n      MindMeldMicrophone.emit('result', result, resultIndex, results, event);\n    });\n\n    listener.on('start', function (event) {\n      hasVoiceResult = false;\n      notAllowed = false;\n      MindMeldMicrophone.emit('start', event);\n    });\n\n    listener.on('end', function (event) {\n      // Check if we received any listener results.\n      if (!notAllowed && !hasVoiceResult) {\n        MindMeldMicrophone.emit('error', {error: 'no-speech'});\n      }\n      MindMeldMicrophone.emit('end', event);\n    });\n\n    listener.on('error', function (event) {\n      if (event.error == 'not-allowed' || event.error == 'service-not-allowed') {\n        notAllowed = true;\n        var holdMessage = microphoneElement.querySelector('.hold-message');\n        if (holdMessage) {\n          holdMessage.style.display = \"none\";\n        }\n      }\n      MindMeldMicrophone.emit('error', event);\n    });\n  }\n\n  // Initializes the volume monitor used to animate the microphone\n  // as the volume changes\n  function initVolumeMonitor () {\n    var volumePulser = microphoneElement.querySelector('.volume-pulser');\n\n    volumeMonitor = new window.VolumeMonitor({\n      listener: listener,\n\n      // Animate volume pulser by scaling a background circle based on volume\n      onVolumeChange: function onVolumeChanged (volume) {\n        var scale = ((volume / 100) * 0.5) + 1.0;\n        volumePulser.style.transform = 'scale(' + scale + ')';\n      },\n\n      // Hide volume pulser on stop\n      onStop: function onVolumeMonitorStopped () {\n        volumePulser.style.transform = 'scale(0.9)';\n      },\n\n      // Public microphone error event when there is a volume monitor error\n      onError: function onVolumeMonitorError (error) {\n        MindMeldMicrophone.emit('error', error);\n      }\n    });\n  }\n\n  // Initializes mouse click handlers to start/stop the microphone\n  function initClickHandlers () {\n    var holdTimeout = null;\n    var holdDuration = 1000;\n\n    var micButton = microphoneElement.querySelector('.icon-container');\n    micButton.addEventListener('mousedown', onMouseDown);\n    micButton.addEventListener('touchstart',\n      // some mobile devices fire both 'touchstart' and 'mousedown'\n      // this prevents trying to start the listener twice at\n      // the same time\n      function onTouchStart (e) {\n        e.stopPropagation();\n        e.preventDefault();\n        onMouseDown();\n      }\n    );\n\n    function onMouseDown () {\n      if (listener.listening) {\n        MindMeldMicrophone.stop();\n      } else {\n        holdTimeout = setTimeout(\n          function startContinuousOnHold () {\n            MindMeldMicrophone.start(true); // start mic in continuous mode\n            holdTimeout = null;\n          },\n          holdDuration\n        );\n      }\n    }\n\n    micButton.addEventListener('mouseup', onMouseUp);\n    micButton.addEventListener('touchend',\n      function onTouchEnd (e) {\n        e.stopPropagation();\n        e.preventDefault();\n        onMouseUp();\n      }\n    );\n\n    function onMouseUp () {\n      if (holdTimeout !== null) {\n        // We have not reached the hold timeout yet, start mic in normal mode\n        clearTimeout(holdTimeout);\n        holdTimeout = null;\n        MindMeldMicrophone.start();\n      }\n    }\n\n    micButton.addEventListener('mouseout', onMouseOut);\n    micButton.addEventListener('touchleave',\n      function onTouchLeave (e) {\n        e.stopPropagation();\n        e.preventDefault();\n        onMouseOut();\n      }\n    );\n\n    function onMouseOut () {\n      clearTimeout(holdTimeout);\n      holdTimeout = null;\n    }\n  }\n\n  // Subscribes to microphone start/stop events to add CSS classes\n  // indicating listening, lock, or waiting state\n  function initUIHandlers () {\n    MindMeldMicrophone.on('start', function onMicrophoneStart () {\n      microphoneElement.classList.add('listening');\n      if (listener.continuous) {\n        microphoneElement.classList.add('lock');\n      }\n    });\n\n    MindMeldMicrophone.on('end', function onMicrophoneEnd () {\n      microphoneElement.classList.remove('listening');\n      microphoneElement.classList.remove('lock');\n    });\n\n  }\n\n\n  // Publicly Accessible Methods of mindmeld-microphone widget\n\n  /**\n   * Start recording\n   */\n  MindMeldMicrophone.start = function start (continuous) {\n    if (notAllowed) {\n      return;\n    }\n\n    listener.continuous = continuous;\n    listener.start();\n\n    /* The volume monitor started causing \"audio-capture\" errors from webkitSpeechRecognition between\n     * Chrome 40.0.2214.38 beta (64-bit) and 40.0.2214.45 beta (64-bit). We are disabling it for now.\n     */\n    //volumeMonitor.start();\n  };\n\n  /**\n   * Returns if the microphone is currently listening\n   */\n  MindMeldMicrophone.listening = function listening () {\n    if (notAllowed) {\n      return false;\n    }\n\n    return listener.listening;\n  };\n\n  /**\n   * Stops recording\n   */\n  MindMeldMicrophone.stop = function stop () {\n    if (notAllowed) {\n      return;\n    }\n\n    listener.cancel();\n  };\n\n  // Event Dispatcher\n  var subscriptions = {};\n\n  /**\n   * Subscribe to microphone events\n   */\n  MindMeldMicrophone.on = function on (eventName, callback, context) {\n    if (! subscriptions[eventName]) {\n      subscriptions[eventName] = [];\n    }\n    var subscription = {\n      callback: callback,\n      context: context\n    };\n    subscriptions[eventName].push(subscription);\n  };\n\n  /**\n   * Publish microphone events to subscribers\n   */\n  MindMeldMicrophone.emit = function emit (eventName) {\n    var subscribers = subscriptions[eventName];\n    if (subscribers !== undefined) {\n      var args = Array.prototype.slice.call(arguments, 1);\n      subscribers.forEach(\n        function invokeCallback (subscription) {\n          var context = subscription.context || this;\n          subscription.callback.apply(context , args);\n        }\n      );\n    }\n  };\n\n  /**\n   * Check if microphone is in continuous mode.\n   */\n  MindMeldMicrophone.isContinuous = function () {\n    if (notAllowed) {\n      return false;\n    }\n\n    return listener && listener.continuous;\n  };\n\n}(MM));\n"],"sourceRoot":"/source/"}